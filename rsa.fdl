ipblock my_arm {
	iptype "armsystem";
	ipparm "exec=rsadrive";
}

ipblock m_req(out data : ns(32)) {
	iptype "armsystemsource";
	ipparm "core=my_arm";
	ipparm "address=0x80000000";
}

ipblock m_ack(in data : ns(32)) {
	iptype "armsystemsink";
	ipparm "core=my_arm";
	ipparm "address=0x80000004";
}

ipblock m_data_out(out data : ns(32)) {
	iptype "armsystemsource";
	ipparm "core=my_arm";
	ipparm "address=0x80000008";
}

ipblock m_data_in(in data : ns(32)) {
	iptype "armsystemsink";
	ipparm "core=my_arm";
	ipparm "address=0x8000000C";
}


dp rsa(	in p_in, q_in	: ns(32);
		in m_in			: ns(32);
		in go			: ns( 1);
		out ready		: ns( 1);
		out result		: ns(32)) {
	
	reg n, e, z, d, c, m: ns(32); // c must be initialized 1. d must be initialized 2
	sig done			: ns( 1);
	reg phase			: ns( 1); // 0 for encyption, 1 for decryption
	
	always {
		// n = p_in * q_in;
		// z = (p_in - 1) * (q_in - 1);
		// e = z - 1;	// e must be co-prime to z and smaller than z :)
		d = ( phase == 0 )
			? ( ( ( d * e ) % z == 1 ) ? d : d + 1 )
			: ( d - 1 );			
		c = ( ( e > 0 ) ? c * m : c % n );
		e = e - 1;
		m = ( phase == 0 )
			? 0
			: ( ( d > 0 ) ? m * c : m % n );
		
		ready = (e == 0 & phase == 0) | (d == 0 & phase == 1);
		result = (phase == 0) ? c : m;
	}
	
}


dp tb_rsa {

	sig p, q	: ns(32);
	sig m		: ns(32);
	sig go		: ns( 1);
	sig ready	: ns( 1);
	sig result	: ns(32);
	use rsa( p, q, m, go, ready, result );
	
	use my_arm;
	
	sig req, ack, data_out, data_in : ns(32);
	use m_req(req);
	use m_ack(ack);
	use m_data_out(data_out);
	use m_data_in(data_in);
	
	reg r_req		: ns( 1);
	reg r_done		: ns( 1);
	reg r_p, r_q	: ns(32);
	reg r_m			: ns(32);
	
	always {
		r_req = req;
		r_done = ready;
		data_in = result;
		p = r_p;
		q = r_q;
		m = r_m;
	}
	
	sfg ack0 { ack = 0; }
	sfg ack1 { ack = 1; }
	sfg getp { r_p = data_out; }
	sfg getq { r_q = data_out; }
	sfg getm { r_m = data_out; }
	sfg start { go = 1; }
	sfg wait { go = 0; }

}

